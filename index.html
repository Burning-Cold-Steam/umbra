<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Poster</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@600;700;800&family=Inter:wght@500;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0b0c10;
      --panel:rgba(255,255,255,.06);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --border:rgba(255,255,255,.14);
      --shadow:0 10px 30px rgba(0,0,0,.55);
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background:radial-gradient(1000px 700px at 30% 20%,#182033 0%,var(--bg) 55%);
      color:var(--text);
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    .wrap{width:min(960px,94vw)}
    .card{
      background:linear-gradient(180deg,var(--panel),rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;

      display:grid;
      place-items:center;
      padding:18px;
    }

    /* Always portrait (social). Same ratio across desktop/mobile. */
    .poster{
      width:min(420px, 96vw);
      aspect-ratio:9/16;
      max-height:92vh;
      margin:0 auto;

      position:relative;
      background:rgba(0,0,0,.25);
      user-select:none;
      overflow:hidden;
      touch-action:none;
    }

    .stage{position:absolute; inset:0; overflow:hidden; z-index:1;}
    .stage img{
      position:absolute;
      left:50%; top:50%;
      transform-origin:center;
      max-width:none;
      pointer-events:none;
      -webkit-user-drag:none;
      filter: contrast(1.07) saturate(1.15) brightness(1.03) sepia(0.06);
    }

    .grade{
      position:absolute; inset:0; pointer-events:none; z-index:3;
      background:
        radial-gradient(120% 110% at 50% 45%, rgba(0,0,0,0.00) 45%, rgba(0,0,0,0.40) 100%),
        linear-gradient(180deg, rgba(255,255,255,0.05), rgba(0,0,0,0.12));
    }
    .grain{
      position:absolute; inset:0; pointer-events:none; z-index:4;
      opacity:.08;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      background-size:180px 180px;
    }

    .uploadOverlay{
      position:absolute; inset:0;
      display:grid; place-items:center;
      padding:22px;
      background:linear-gradient(180deg,rgba(0,0,0,.25),rgba(0,0,0,.35));
      transition:opacity .25s ease, transform .25s ease;
      z-index:10;
    }
    .dropzone{
      width:min(520px,92%);
      border:1px dashed rgba(255,255,255,.25);
      border-radius:16px;
      padding:22px;
      text-align:center;
      background:rgba(255,255,255,.04);
    }
    .dropzone h2{margin:0 0 8px;font-size:18px;font-weight:750}
    .dropzone p{margin:0 0 14px;color:var(--muted);font-size:14px;line-height:1.35}
    .btnRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}

    button{
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      color:var(--text);
      padding:10px 14px;
      border-radius:12px;
      cursor:pointer;
      font-weight:650;
      letter-spacing:.2px;
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    button:hover{background:rgba(255,255,255,.11)}
    button:active{transform:translateY(1px)}
    button:disabled{opacity:.55;cursor:not-allowed;transform:none}

    .controls{
      position:absolute; top:14px; left:14px; right:14px;
      display:none;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
      z-index:20;
    }

    .hint{
      position:absolute; top:14px; left:14px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.28);
      color:rgba(255,255,255,.78);
      font-size:12px;
      z-index:20;
      opacity:1;
      transition:opacity .35s ease;
    }
    .hintHidden .hint{opacity:0; pointer-events:none;}

    .affirmation{
      position:absolute; left:16px; right:16px; bottom:18px;
      padding:16px 18px;
      text-align:center;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.34);
      backdrop-filter:blur(10px);
      -webkit-backdrop-filter:blur(10px);
      z-index:30;

      opacity:0;
      transform:translateY(12px);
      transition:opacity .65s ease, transform .65s ease;
    }
    .affirmation .main{
      font-family:"Playfair Display", serif;
      font-size:clamp(26px,3.1vw,38px);
      font-weight:800;
      margin:0;
      line-height:1.12;
      letter-spacing:.2px;
    }
    .affirmation .sub{
      margin:8px 0 0;
      color:rgba(255,255,255,.78);
      font-size:13px;
      line-height:1.25;
    }

    .loaded .uploadOverlay{opacity:0;pointer-events:none;transform:scale(.985)}
    .loaded .controls{display:flex}
    .reveal .affirmation{opacity:1;transform:none}
    .retryHidden #retryBtn{display:none}

    .busyOverlay{
      position:absolute; inset:0;
      display:grid; place-items:center;
      z-index:60;
      pointer-events:none;
      opacity:0;
      transition:opacity .15s ease;
      background:rgba(0,0,0,.35);
    }
    .busyOverlay.show{opacity:1; pointer-events:auto;}
    .busyCard{
      width:min(360px, 88%);
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.45);
      border-radius:16px;
      padding:16px 16px;
      text-align:center;
      backdrop-filter:blur(10px);
      -webkit-backdrop-filter:blur(10px);
    }
    .busyTitle{margin:0 0 6px; font-weight:800; font-size:14px}
    .busyText{margin:0; color:rgba(255,255,255,.75); font-size:13px; line-height:1.25}
    .spinner{
      width:18px; height:18px;
      border-radius:999px;
      border:2px solid rgba(255,255,255,.25);
      border-top-color:rgba(255,255,255,.85);
      margin:10px auto 0;
      animation:spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .saveViewer{
      position:fixed; inset:0;
      z-index:9999;
      background:rgba(0,0,0,.92);
      display:none;
      padding:14px;
      overflow:auto;
    }
    .saveViewer.show{display:block;}
    .svTop{
      position:sticky; top:0;
      background:rgba(0,0,0,.82);
      backdrop-filter:blur(10px);
      -webkit-backdrop-filter:blur(10px);
      border-bottom:1px solid rgba(255,255,255,.12);
      padding:10px 0 12px;
      margin-bottom:12px;
    }
    .svRow{
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      max-width:900px; margin:0 auto;
    }
    .svText{max-width:620px;}
    .svText h3{margin:0 0 4px; font-size:14px; font-weight:850}
    .svText p{margin:0; font-size:12px; color:rgba(255,255,255,.78); line-height:1.35}
    .svImgWrap{display:grid;place-items:center;max-width:900px;margin:0 auto 30px;}
    .svImg{max-width:100%;height:auto;border-radius:14px;border:1px solid rgba(255,255,255,.12)}
    .svBtns{display:flex;gap:10px;flex-wrap:wrap}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div id="poster" class="poster">
        <div class="stage">
          <img id="photo" alt="" />
        </div>

        <div class="grade"></div>
        <div class="grain"></div>

        <div class="controls">
          <button type="button" id="downloadPng" disabled>Download PNG</button>
          <button type="button" id="copyPng" disabled>Copy PNG</button>
          <button type="button" id="saveViewBtn" disabled>Save / Share</button>
          <button type="button" id="fitBtn" disabled>Fit</button>
          <button type="button" id="retryBtn" disabled>Start over</button>
        </div>

        <div class="hint" id="hint">Drag to reposition • Scroll/pinch to zoom</div>

        <div class="affirmation" aria-live="polite">
          <p class="main" id="affirmMain"></p>
          <p class="sub" id="affirmSub"></p>
        </div>

        <div class="uploadOverlay">
          <div class="dropzone" id="dropzone">
            <h2>Add your photo</h2>
            <p>Choose or drop an image. The message appears after the photo loads.</p>
            <div class="btnRow">
              <button type="button" id="chooseBtn">Choose image</button>
            </div>
            <input id="file" type="file" accept="image/*" hidden>
          </div>
        </div>

        <div class="busyOverlay" id="busy">
          <div class="busyCard">
            <p class="busyTitle" id="busyTitle">Working…</p>
            <p class="busyText" id="busyText">This can take a moment.</p>
            <div class="spinner"></div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <div class="saveViewer" id="saveViewer" aria-modal="true" role="dialog">
    <div class="svTop">
      <div class="svRow">
        <div class="svText">
          <h3>Save your poster</h3>
          <p>
            iPhone/iPad: press and hold the image → <b>Save to Photos</b> / <b>Share</b>.<br>
            Android: long-press → <b>Download image</b> or share. Desktop: right-click → Save image.
          </p>
        </div>
        <div class="svBtns">
          <a id="svDownloadLink" href="#" download="poster.png"><button type="button">Try Download</button></a>
          <button type="button" id="svClose">Close</button>
        </div>
      </div>
    </div>
    <div class="svImgWrap">
      <img class="svImg" id="svImg" alt="Your poster" />
    </div>
  </div>

  <script>
    const poster = document.getElementById('poster');
    const photo = document.getElementById('photo');
    const fileInput = document.getElementById('file');
    const chooseBtn = document.getElementById('chooseBtn');
    const dropzone = document.getElementById('dropzone');

    const affirmMain = document.getElementById('affirmMain');
    const affirmSub  = document.getElementById('affirmSub');

    const downloadBtn = document.getElementById('downloadPng');
    const copyBtn = document.getElementById('copyPng');
    const saveViewBtn = document.getElementById('saveViewBtn');
    const fitBtn = document.getElementById('fitBtn');
    const retryBtn = document.getElementById('retryBtn');

    const busy = document.getElementById('busy');
    const busyTitle = document.getElementById('busyTitle');
    const busyText = document.getElementById('busyText');

    const saveViewer = document.getElementById('saveViewer');
    const svImg = document.getElementById('svImg');
    const svClose = document.getElementById('svClose');
    const svDownloadLink = document.getElementById('svDownloadLink');

    const ua = navigator.userAgent || "";
    const isIOS = /iPad|iPhone|iPod/i.test(ua) && !window.MSStream;

    let sourceBitmap = null;
    let sourceImageEl = null;
    let currentObjectURL = null;

    // --- affirmations ---
    const MORNING = [
      { main: "This person is allowed a gentle start.", sub: "You don’t need to rush to be worthy." },
      { main: "This person is doing better than they think.", sub: "Even small steps count." },
      { main: "This person deserves a calm morning.", sub: "Softness is strength." },
      { main: "This person can begin again.", sub: "Fresh doesn’t have to be loud." },
      { main: "This person is capable today.", sub: "One thing at a time." },
      { main: "This person is enough already.", sub: "Before they prove anything." },
      { main: "This person matters.", sub: "More than they realise." },
      { main: "This person is worthy of good things.", sub: "No conditions attached." }
    ];
    const AFTERNOON = [
      { main: "This person’s effort matters.", sub: "Especially the unseen parts." },
      { main: "This person is learning, not failing.", sub: "Growth looks messy sometimes." },
      { main: "This person deserves kindness today.", sub: "From others — and themselves." },
      { main: "This person can take up space.", sub: "They were never ‘too much’." },
      { main: "This person is more capable than they feel.", sub: "Feelings are not facts." },
      { main: "This person is loved and appreciated.", sub: "More than they know." },
      { main: "This person belongs.", sub: "There is space for you here." },
      { main: "This person’s pace is the right pace.", sub: "Life isn’t a race." }
    ];
    const EVENING = [
      { main: "This person did enough for one day.", sub: "Rest is part of the work." },
      { main: "This person deserves gentleness.", sub: "Especially from themselves." },
      { main: "This person is safe to slow down.", sub: "Nothing needs proving tonight." },
      { main: "This person is proud-worthy.", sub: "Even for simply getting through." },
      { main: "This person is seen.", sub: "Even when they feel invisible." },
      { main: "This person is enough.", sub: "Right now. As-is." },
      { main: "This person is held in good regard.", sub: "More than they realise." }
    ];
    const LATE = [
      { main: "This person is allowed to rest.", sub: "Worth is not earned through exhaustion." },
      { main: "This person is not a burden.", sub: "They never were." },
      { main: "This person has survived everything so far.", sub: "That counts for something." },
      { main: "This person’s story isn’t finished.", sub: "There’s more ahead." },
      { main: "This person deserves peace.", sub: "Even if it starts small." },
      { main: "This person is worthy, exactly as they are.", sub: "No performance required." },
      { main: "This person is stronger than the hard days.", sub: "Quiet strength still counts." }
    ];

    function dayPart(){
      const h = new Date().getHours();
      if (h >= 5 && h < 12) return "morning";
      if (h >= 12 && h < 17) return "afternoon";
      if (h >= 17 && h < 22) return "evening";
      return "late";
    }
    function pickAffirmation(){
      const p = dayPart();
      const pool = (p === "morning") ? MORNING
                 : (p === "afternoon") ? AFTERNOON
                 : (p === "evening") ? EVENING
                 : LATE;
      const pick = pool[Math.floor(Math.random() * pool.length)];
      affirmMain.textContent = pick.main;
      affirmSub.textContent  = pick.sub;
    }

    // --- transform state ---
    let scale = 1, x = 0, y = 0;
    let baseScale = 1, minScale = 0.2, maxScale = 3.0;

    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
    function apply(){
      photo.style.transform = `translate(-50%,-50%) translate(${x}px,${y}px) scale(${scale})`;
    }
    function computeContainScale(){
      const pw = poster.clientWidth;
      const ph = poster.clientHeight;
      const iw = photo.naturalWidth || 1;
      const ih = photo.naturalHeight || 1;
      return Math.min(pw / iw, ph / ih) * 0.98;
    }

    const pointers = new Map();
    let lastPinchDist = null;
    function resetGestureBaseline(){
      pointers.clear();
      lastPinchDist = null;
    }

    function fitToScreen(){
      x = 0; y = 0;
      baseScale = computeContainScale();
      scale = baseScale;
      minScale = baseScale * 0.35;
      maxScale = Math.max(3.0, baseScale * 6);
      apply();
      resetGestureBaseline();
    }

    // --- one-time timers from first image load ---
    let timersStarted = false;
    function startOneTimeTimers(){
      if (timersStarted) return;
      timersStarted = true;

      poster.classList.remove('reveal');
      poster.classList.remove('hintHidden');
      poster.classList.add('retryHidden');

      setTimeout(() => poster.classList.add('hintHidden'), 5000);
      setTimeout(() => poster.classList.add('reveal'), 6000);
      setTimeout(() => poster.classList.remove('retryHidden'), 20000);
    }

    // --- busy overlay ---
    function showBusy(title, text){
      busyTitle.textContent = title || "Working…";
      busyText.textContent = text || "This can take a moment.";
      busy.classList.add('show');
    }
    function hideBusy(){
      busy.classList.remove('show');
    }

    // --- save viewer ---
    function openSaveViewer(dataUrl){
      svImg.src = dataUrl;
      svDownloadLink.href = dataUrl;
      saveViewer.classList.add('show');
      document.documentElement.style.overflow = 'hidden';
      document.body.style.overflow = 'hidden';
    }
    function closeSaveViewer(){
      saveViewer.classList.remove('show');
      svImg.src = "";
      document.documentElement.style.overflow = '';
      document.body.style.overflow = '';
    }
    svClose.addEventListener('click', closeSaveViewer);
    saveViewer.addEventListener('click', (e) => {
      if (e.target === saveViewer) closeSaveViewer();
    });

    // --- upload handling ---
    chooseBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (f) loadImage(f);
    });
    dropzone.addEventListener('dragover', (e) => e.preventDefault());
    dropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if (f) loadImage(f);
    });

    function enableControls(){
      downloadBtn.disabled = false;
      copyBtn.disabled = false;
      saveViewBtn.disabled = false;
      fitBtn.disabled = false;
      retryBtn.disabled = false;
    }

    async function safeDecodeToBitmap(fileObj){
      if (!('createImageBitmap' in window)) return null;
      try{ return await createImageBitmap(fileObj); } catch { return null; }
    }
    function safeDecodeToImageElement(url){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    async function loadImage(fileObj){
      pickAffirmation();

      if (currentObjectURL) URL.revokeObjectURL(currentObjectURL);
      currentObjectURL = URL.createObjectURL(fileObj);

      photo.onload = () => {
        poster.classList.add('loaded');
        enableControls();
        fitToScreen();
        startOneTimeTimers();
      };
      photo.src = currentObjectURL;
      photo.alt = "User photo";

      try{
        const bmp = await safeDecodeToBitmap(fileObj);
        sourceBitmap = bmp || null;
      } catch {
        sourceBitmap = null;
      }

      if (!sourceBitmap){
        sourceImageEl = await safeDecodeToImageElement(currentObjectURL);
      }
    }

    fitBtn.addEventListener('click', () => {
      if(!poster.classList.contains('loaded')) return;
      fitToScreen();
    });

    // --- Start over: FULL reset (not just new affirmation) ---
    function resetExperience(){
      // Close overlays if any
      try { closeSaveViewer(); } catch {}

      poster.classList.remove('loaded', 'reveal', 'hintHidden');
      poster.classList.add('retryHidden');

      timersStarted = false;

      scale = 1; x = 0; y = 0; baseScale = 1;
      minScale = 0.2; maxScale = 3.0;
      apply();
      resetGestureBaseline();

      photo.removeAttribute('src');
      photo.alt = "";

      if (currentObjectURL) {
        URL.revokeObjectURL(currentObjectURL);
        currentObjectURL = null;
      }

      if (sourceBitmap && typeof sourceBitmap.close === "function") {
        try { sourceBitmap.close(); } catch {}
      }
      sourceBitmap = null;
      sourceImageEl = null;

      downloadBtn.disabled = true;
      copyBtn.disabled = true;
      saveViewBtn.disabled = true;
      fitBtn.disabled = true;
      retryBtn.disabled = true;

      fileInput.value = "";

      pickAffirmation();
    }

    retryBtn.addEventListener('click', () => {
      resetExperience();
    });

    // --- gestures (stable; iOS damped) ---
    const DRAG_SENS = isIOS ? 0.45 : 1.0;
    const PINCH_SENS = isIOS ? 0.18 : 1.0;
    const PINCH_DEADZONE = isIOS ? 0.012 : 0.0;
    const MAX_SCALE_STEP = isIOS ? 0.020 : 0.06;

    let needsApply = false;
    function scheduleApply(){
      if (needsApply) return;
      needsApply = true;
      requestAnimationFrame(() => {
        needsApply = false;
        apply();
      });
    }
    function getDist(a, b){
      const dx = a.clientX - b.clientX;
      const dy = a.clientY - b.clientY;
      return Math.hypot(dx, dy);
    }

    poster.addEventListener('pointerdown', (e) => {
      if (e.target.closest('button') || e.target.closest('input') || e.target.closest('#dropzone')) return;
      if(!poster.classList.contains('loaded')) return;

      pointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });
      poster.setPointerCapture?.(e.pointerId);

      if (pointers.size === 2){
        const [p1, p2] = Array.from(pointers.values());
        lastPinchDist = getDist(p1, p2);
      }
    });

    poster.addEventListener('pointermove', (e) => {
      if(!pointers.has(e.pointerId)) return;

      const prev = pointers.get(e.pointerId);
      const curr = { clientX: e.clientX, clientY: e.clientY };
      pointers.set(e.pointerId, curr);

      if (pointers.size === 1){
        x += (curr.clientX - prev.clientX) * DRAG_SENS;
        y += (curr.clientY - prev.clientY) * DRAG_SENS;
        scheduleApply();
        return;
      }

      if (pointers.size === 2){
        const [p1, p2] = Array.from(pointers.values());
        const dist = getDist(p1, p2);
        if (!lastPinchDist){ lastPinchDist = dist; return; }

        const rawRatio = dist / lastPinchDist;
        lastPinchDist = dist;

        if (Math.abs(rawRatio - 1) < PINCH_DEADZONE) return;

        const intendedRatio = 1 + ((rawRatio - 1) * PINCH_SENS);
        const nextScale = scale * intendedRatio;

        const delta = nextScale - scale;
        const clampedDelta = clamp(delta, -MAX_SCALE_STEP, MAX_SCALE_STEP);

        scale = clamp(scale + clampedDelta, minScale, maxScale);
        scheduleApply();
      }
    });

    function endPointer(e){
      pointers.delete(e.pointerId);
      if (pointers.size < 2) lastPinchDist = null;
      poster.releasePointerCapture?.(e.pointerId);
    }
    poster.addEventListener('pointerup', endPointer);
    poster.addEventListener('pointercancel', endPointer);

    poster.addEventListener('wheel', (e) => {
      if(!poster.classList.contains('loaded')) return;
      e.preventDefault();
      const delta = -Math.sign(e.deltaY);
      const factor = (delta > 0) ? 1.08 : 0.92;
      scale = clamp(scale * factor, minScale, maxScale);
      apply();
    }, { passive:false });

    window.addEventListener('resize', () => {
      if (!poster.classList.contains('loaded')) return;
      const prevBase = baseScale || 1;
      const rel = scale / prevBase;

      baseScale = computeContainScale();
      minScale = baseScale * 0.35;
      maxScale = Math.max(3.0, baseScale * 6);

      scale = clamp(baseScale * rel, minScale, maxScale);
      apply();
      resetGestureBaseline();
    });

    // --- Export compositor (no UI capture) ---
    function getExportSize(){
      return { w: 1080, h: 1920 }; // always social portrait
    }

    function getCurrentPosterState(){ return { x, y, scale }; }
    function getSourceDims(){
      if (sourceBitmap) return { w: sourceBitmap.width, h: sourceBitmap.height };
      if (sourceImageEl) return { w: sourceImageEl.naturalWidth, h: sourceImageEl.naturalHeight };
      return { w: photo.naturalWidth || 1, h: photo.naturalHeight || 1 };
    }
    function getSourceDrawable(){ return sourceBitmap || sourceImageEl || photo; }

    function drawVignette(ctx, w, h){
      const g = ctx.createRadialGradient(w*0.5, h*0.45, Math.min(w,h)*0.20, w*0.5, h*0.45, Math.max(w,h)*0.72);
      g.addColorStop(0.0, "rgba(0,0,0,0)");
      g.addColorStop(1.0, "rgba(0,0,0,0.42)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);

      const g2 = ctx.createLinearGradient(0,0,0,h);
      g2.addColorStop(0,"rgba(255,255,255,0.06)");
      g2.addColorStop(1,"rgba(0,0,0,0.10)");
      ctx.fillStyle = g2;
      ctx.fillRect(0,0,w,h);
    }

    function drawGrain(ctx, w, h){
      const grainCanvas = document.createElement('canvas');
      grainCanvas.width = 220;
      grainCanvas.height = 220;
      const gctx = grainCanvas.getContext('2d');
      const imgData = gctx.createImageData(grainCanvas.width, grainCanvas.height);
      for (let i=0;i<imgData.data.length;i+=4){
        const v = (Math.random()*255)|0;
        imgData.data[i]=v; imgData.data[i+1]=v; imgData.data[i+2]=v;
        imgData.data[i+3]=18;
      }
      gctx.putImageData(imgData,0,0);

      ctx.save();
      ctx.globalAlpha = 0.10;
      ctx.globalCompositeOperation = 'overlay';
      const pattern = ctx.createPattern(grainCanvas,'repeat');
      ctx.fillStyle = pattern;
      ctx.fillRect(0,0,w,h);
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function wrapText(ctx, text, x, y, maxWidth, lineHeight){
      const words = (text || "").split(/\s+/).filter(Boolean);
      if (!words.length) return;
      let line = "";
      const lines = [];
      for (const w of words){
        const test = line ? (line + " " + w) : w;
        if (ctx.measureText(test).width <= maxWidth){
          line = test;
        } else {
          if (line) lines.push(line);
          line = w;
        }
      }
      if (line) lines.push(line);

      const maxLines = 2;
      let out = lines.slice(0, maxLines);
      if (lines.length > maxLines){
        out[maxLines-1] = out[maxLines-1].replace(/\s+\S+$/, "…");
      }

      const totalH = out.length * lineHeight;
      let yy = y - totalH/2 + lineHeight/2;
      for (const l of out){
        ctx.fillText(l, x, yy);
        yy += lineHeight;
      }
    }

    function drawAffirmationBox(ctx, w, h){
      const padX = Math.round(w * 0.06);
      const boxW = w - padX*2;
      const boxH = Math.round(h * 0.17);
      const x0 = padX;
      const y0 = h - boxH - Math.round(h*0.04);

      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.34)";
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = Math.max(2, Math.round(w*0.002));
      roundRect(ctx, x0, y0, boxW, boxH, Math.round(w*0.035));
      ctx.fill();
      ctx.stroke();

      const main = affirmMain.textContent || "";
      const sub  = affirmSub.textContent || "";

      const mainSize = Math.round(Math.min(72, Math.max(40, w*0.040)));
      const subSize  = Math.round(Math.min(28, Math.max(20, w*0.018)));

      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.font = `800 ${mainSize}px "Playfair Display", Georgia, serif`;
      wrapText(ctx, main, w/2, y0 + boxH*0.42, boxW*0.90, mainSize*1.08);

      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = `600 ${subSize}px Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
      wrapText(ctx, sub, w/2, y0 + boxH*0.74, boxW*0.88, subSize*1.20);

      ctx.restore();
    }

    function buildExportCanvas(){
      const { w, h } = getExportSize();
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d', { alpha:false });

      ctx.fillStyle = "#0b0c10";
      ctx.fillRect(0,0,w,h);

      const drawable = getSourceDrawable();
      const sd = getSourceDims();

      const pxToExportX = w / poster.clientWidth;
      const pxToExportY = h / poster.clientHeight;
      const exportScaleFactor = (pxToExportX + pxToExportY) / 2;

      const state = getCurrentPosterState();
      const cx = w / 2 + state.x * pxToExportX;
      const cy = h / 2 + state.y * pxToExportY;

      const drawW = sd.w * state.scale * exportScaleFactor;
      const drawH = sd.h * state.scale * exportScaleFactor;

      ctx.save();
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.filter = 'contrast(1.07) saturate(1.15) brightness(1.03) sepia(0.06)';
      ctx.drawImage(drawable, cx - drawW/2, cy - drawH/2, drawW, drawH);
      ctx.restore();

      drawVignette(ctx, w, h);
      drawGrain(ctx, w, h);
      drawAffirmationBox(ctx, w, h);

      return canvas;
    }

    async function canvasToBlob(canvas){
      return await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
    }

    async function ensureFontsReady(){
      if (document.fonts && document.fonts.ready) {
        try { await document.fonts.ready; } catch {}
      }
    }

    async function downloadPNG(){
      if(!poster.classList.contains('loaded')) return;

      showBusy("Preparing image…", "Creating a clean export.");
      try{
        await ensureFontsReady();
        const canvas = buildExportCanvas();

        if (!isIOS){
          const blob = await canvasToBlob(canvas);
          const url = URL.createObjectURL(blob);

          const a = document.createElement('a');
          a.href = url;
          a.download = "poster.png";
          document.body.appendChild(a);
          a.click();
          a.remove();

          setTimeout(() => URL.revokeObjectURL(url), 1500);
        } else {
          openSaveViewer(canvas.toDataURL("image/png"));
        }
      } finally {
        hideBusy();
      }
    }

    async function copyPNG(){
      if(!poster.classList.contains('loaded')) return;

      showBusy("Preparing image…", "Copying (or opening save screen).");
      try{
        await ensureFontsReady();
        const canvas = buildExportCanvas();

        if (!isIOS && navigator.clipboard && window.ClipboardItem) {
          const blob = await canvasToBlob(canvas);
          try{
            await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
            alert("Copied as PNG. Paste into apps that support image paste.");
            return;
          } catch {}
        }

        openSaveViewer(canvas.toDataURL("image/png"));
      } finally {
        hideBusy();
      }
    }

    async function saveShare(){
      if(!poster.classList.contains('loaded')) return;

      showBusy("Preparing image…", "Opening a save/share screen.");
      try{
        await ensureFontsReady();
        const canvas = buildExportCanvas();
        openSaveViewer(canvas.toDataURL("image/png"));
      } finally {
        hideBusy();
      }
    }

    downloadBtn.addEventListener('click', downloadPNG);
    copyBtn.addEventListener('click', copyPNG);
    saveViewBtn.addEventListener('click', saveShare);

    // init
    poster.classList.add('retryHidden');
    pickAffirmation();
    apply();
  </script>
</body>
</html>
