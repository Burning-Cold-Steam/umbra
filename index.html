<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Poster</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;700;800&family=Inter:wght@500;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0b0c10;
      --panel:rgba(255,255,255,.06);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --border:rgba(255,255,255,.14);
      --shadow:0 10px 30px rgba(0,0,0,.55);
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background:radial-gradient(1000px 700px at 30% 20%,#182033 0%,var(--bg) 55%);
      color:var(--text);
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    .wrap{width:min(960px,94vw)}
    .card{
      background:linear-gradient(180deg,var(--panel),rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }

    /* Desktop: 4:5 feed friendly */
    .poster{
      width:min(720px, 94vw);
      aspect-ratio:4/5;
      position:relative;
      background:rgba(0,0,0,.25);
      user-select:none;
      touch-action:none;
      overflow:hidden;
    }

    /* Mobile: 9:16 story (tall) + allow it to occupy most of the screen */
    @media(max-width:700px){
      .poster{
        width:min(96vw, 520px);
        aspect-ratio:9/16;
        /* keeps it feeling tall without clipping on short screens */
        max-height:92vh;
      }
    }

    /* Social-ish vignette + grade */
    .grade{
      position:absolute; inset:0; pointer-events:none; z-index:3;
      background:
        radial-gradient(120% 110% at 50% 45%, rgba(0,0,0,0.00) 45%, rgba(0,0,0,0.38) 100%),
        linear-gradient(180deg, rgba(255,255,255,0.05), rgba(0,0,0,0.12));
    }
    .grain{
      position:absolute; inset:0; pointer-events:none; z-index:4;
      opacity:.08;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      background-size:180px 180px;
    }

    /* Upload overlay */
    .uploadOverlay{
      position:absolute; inset:0;
      display:grid; place-items:center;
      padding:22px;
      background:linear-gradient(180deg,rgba(0,0,0,.25),rgba(0,0,0,.35));
      transition:opacity .25s ease, transform .25s ease;
      z-index:10;
    }
    .dropzone{
      width:min(520px,92%);
      border:1px dashed rgba(255,255,255,.25);
      border-radius:16px;
      padding:22px;
      text-align:center;
      background:rgba(255,255,255,.04);
    }
    .dropzone h2{margin:0 0 8px;font-size:18px;font-weight:750}
    .dropzone p{margin:0 0 14px;color:var(--muted);font-size:14px;line-height:1.35}
    .btnRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
    button{
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      color:var(--text);
      padding:10px 14px;
      border-radius:12px;
      cursor:pointer;
      font-weight:650;
      letter-spacing:.2px;
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    button:hover{background:rgba(255,255,255,.11)}
    button:active{transform:translateY(1px)}
    button:disabled{opacity:.55;cursor:not-allowed;transform:none}

    .stage{position:absolute; inset:0; overflow:hidden; z-index:1;}
    .stage img{
      position:absolute; left:50%; top:50%;
      transform-origin:center;
      max-width:none;
      pointer-events:none;
      -webkit-user-drag:none;
      filter: contrast(1.07) saturate(1.15) brightness(1.03) sepia(0.06);
    }

    .controls{
      position:absolute; top:14px; left:14px; right:14px;
      display:none; gap:10px; justify-content:flex-end; flex-wrap:wrap;
      z-index:20;
    }

    .dragHint{
      position:absolute; top:14px; left:14px;
      padding:8px 10px; border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.28);
      color:rgba(255,255,255,.78);
      font-size:12px;
      z-index:20;
      opacity:1;
      transition: opacity .35s ease;
    }
    .hintHidden .dragHint{opacity:0; pointer-events:none;}

    .affirmation{
      position:absolute; left:16px; right:16px; bottom:18px;
      padding:16px 18px;
      text-align:center;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.34);
      backdrop-filter:blur(10px);
      -webkit-backdrop-filter:blur(10px);
      z-index:30;

      opacity:0;
      transform:translateY(12px);
      transition:opacity .65s ease, transform .65s ease;
    }
    .affirmation .main{
      font-family:"Playfair Display", serif;
      font-size:clamp(26px,3.1vw,38px);
      font-weight:800;
      margin:0;
      line-height:1.12;
      letter-spacing:.2px;
    }
    .affirmation .sub{
      margin:8px 0 0;
      color:rgba(255,255,255,.78);
      font-size:13px;
      line-height:1.25;
    }

    .loaded .uploadOverlay{opacity:0;pointer-events:none;transform:scale(.985)}
    .loaded .controls{display:flex}
    .reveal .affirmation{opacity:1;transform:none}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div id="poster" class="poster">
        <div class="stage">
          <img id="photo" alt="" />
        </div>

        <div class="grade"></div>
        <div class="grain"></div>

        <div class="controls">
          <button type="button" id="downloadPng" disabled>Download PNG</button>
          <button type="button" id="copyPng" disabled>Copy PNG</button>
        </div>

        <div class="dragHint" id="dragHint">Drag to reposition • Scroll/pinch to zoom</div>

        <div class="affirmation" aria-live="polite">
          <p class="main" id="affirmMain"></p>
          <p class="sub" id="affirmSub"></p>
        </div>

        <div class="uploadOverlay">
          <div class="dropzone" id="dropzone">
            <h2>Add your photo</h2>
            <p>Choose or drop an image. The message appears after the photo loads.</p>
            <div class="btnRow">
              <button type="button" id="chooseBtn">Choose image</button>
            </div>
            <input id="file" type="file" accept="image/*" hidden>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <script>
    const poster = document.getElementById('poster');
    const photo = document.getElementById('photo');
    const file = document.getElementById('file');
    const chooseBtn = document.getElementById('chooseBtn');
    const dropzone = document.getElementById('dropzone');

    const affirmMain = document.getElementById('affirmMain');
    const affirmSub  = document.getElementById('affirmSub');

    const downloadBtn = document.getElementById('downloadPng');
    const copyBtn = document.getElementById('copyPng');

    const AFFIRMATIONS = [
  { main: "This person is loved and appreciated.", sub: "You’re doing better than you think." },
  { main: "This person matters more than they realise.", sub: "Your presence changes rooms." },
  { main: "This person is worthy, exactly as they are.", sub: "No performance required." },
  { main: "This person deserves gentleness.", sub: "Especially from themselves." },
  { main: "This person is stronger than the hard days.", sub: "Quiet strength still counts." },
  { main: "This person belongs.", sub: "There is space for you here." },
  { main: "This person is enough.", sub: "Right now. As-is." },
  { main: "This person is seen.", sub: "Even when they feel invisible." },
  { main: "This person’s effort matters.", sub: "Even when no one applauds it." },
  { main: "This person is allowed to rest.", sub: "Worth is not earned through exhaustion." },
  { main: "This person carries more courage than they notice.", sub: "Showing up is brave." },
  { main: "This person is learning, not failing.", sub: "Growth is rarely loud." },
  { main: "This person’s feelings are valid.", sub: "They don’t need permission to exist." },
  { main: "This person has survived everything so far.", sub: "That counts for something." },
  { main: "This person brings value just by being here.", sub: "Nothing else required." },
  { main: "This person is allowed to take up space.", sub: "Softly or boldly." },
  { main: "This person is not behind.", sub: "Life isn’t a race." },
  { main: "This person is doing meaningful work.", sub: "Even when it feels small." },
  { main: "This person deserves kindness.", sub: "From others — and themselves." },
  { main: "This person is trusted to find their way.", sub: "They always have." },
  { main: "This person is allowed to change.", sub: "Growth doesn’t erase who they were." },
  { main: "This person’s story isn’t finished.", sub: "There’s more ahead." },
  { main: "This person is not a burden.", sub: "They never were." },
  { main: "This person brings calm where they go.", sub: "Even without trying." },
  { main: "This person is more capable than they feel today.", sub: "Feelings are not facts." },
  { main: "This person deserves to feel proud.", sub: "Even quietly." },
  { main: "This person is held in good regard.", sub: "More than they know." },
  { main: "This person’s pace is the right pace.", sub: "There is no deadline on becoming." },
  { main: "This person is allowed to hope.", sub: "Even cautiously." },
  { main: "This person is worthy of good things.", sub: "Simply because they exist." }
];

    function pickAffirmation(){
      const pick = AFFIRMATIONS[Math.floor(Math.random() * AFFIRMATIONS.length)];
      affirmMain.textContent = pick.main;
      affirmSub.textContent  = pick.sub;
    }

    // Transform state
    let scale = 1, x = 0, y = 0;
    let baseScale = 1, minScale = 0.2, maxScale = 3.0;

    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
    function apply(){
      photo.style.transform = `translate(-50%,-50%) translate(${x}px,${y}px) scale(${scale})`;
    }

    function computeContainScale(){
      const pw = poster.clientWidth;
      const ph = poster.clientHeight;
      const iw = photo.naturalWidth || 1;
      const ih = photo.naturalHeight || 1;
      return Math.min(pw / iw, ph / ih) * 0.98;
    }

    function resetToContain(){
      x = 0; y = 0;
      baseScale = computeContainScale();
      scale = baseScale;

      // allow zoom-out to create margins
      minScale = baseScale * 0.35;
      maxScale = Math.max(3.0, baseScale * 6);
      apply();
    }

    // Timers: affirmation reveal (6s), hint hide (5s)
    let revealTimer = null;
    let hintTimer = null;

    function scheduleRevealAndHintHide(){
      poster.classList.remove('reveal');
      poster.classList.remove('hintHidden');

      if (revealTimer) clearTimeout(revealTimer);
      if (hintTimer) clearTimeout(hintTimer);

      revealTimer = setTimeout(() => poster.classList.add('reveal'), 6000);
      hintTimer = setTimeout(() => poster.classList.add('hintHidden'), 5000);
    }

    function markLoaded(){
      poster.classList.add('loaded');
      downloadBtn.disabled = false;
      copyBtn.disabled = false;
      scheduleRevealAndHintHide();
    }

    // ✅ Use FileReader to produce a data URL (more reliable for html2canvas + clipboard)
    function loadImage(fileObj){
      if(!fileObj) return;
      pickAffirmation();

      const reader = new FileReader();
      reader.onload = () => {
        photo.onload = () => {
          resetToContain();
          markLoaded();
        };
        photo.src = reader.result; // data URL
        photo.alt = "User photo";
      };
      reader.readAsDataURL(fileObj);
    }

    chooseBtn.onclick = () => file.click();
    file.onchange = e => loadImage(e.target.files[0]);

    dropzone.ondragover = e => e.preventDefault();
    dropzone.ondrop = e => { e.preventDefault(); loadImage(e.dataTransfer.files[0]); };

    // ----- Drag + Pinch Zoom (iOS damped) -----
const isIOS = /iPad|iPhone|iPod/i.test(navigator.userAgent) && !window.MSStream;

// iOS feels “twitchy”, so we damp it
const DRAG_SENS = isIOS ? 0.55 : 1.0;   // drag speed
const PINCH_SENS = isIOS ? 0.35 : 1.0;  // pinch strength (lower = calmer)
const PINCH_DEADZONE = isIOS ? 0.008 : 0.0; // ignore tiny ratio changes

const pointers = new Map();
let lastPinchDist = null;

// rAF batching (reduces jitter)
let needsApply = false;
function scheduleApply(){
  if (needsApply) return;
  needsApply = true;
  requestAnimationFrame(() => {
    needsApply = false;
    apply();
  });
}

function getDist(a, b){
  const dx = a.clientX - b.clientX;
  const dy = a.clientY - b.clientY;
  return Math.hypot(dx, dy);
}

poster.addEventListener('pointerdown', (e) => {
  if(!poster.classList.contains('loaded')) return;

  pointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });
  poster.setPointerCapture?.(e.pointerId);

  if (pointers.size === 2){
    const [p1, p2] = Array.from(pointers.values());
    lastPinchDist = getDist(p1, p2);
  }
});

poster.addEventListener('pointermove', (e) => {
  if(!pointers.has(e.pointerId)) return;

  const prev = pointers.get(e.pointerId);
  const curr = { clientX: e.clientX, clientY: e.clientY };
  pointers.set(e.pointerId, curr);

  if (pointers.size === 1){
    // one-finger drag (damped on iOS)
    const dx = (curr.clientX - prev.clientX) * DRAG_SENS;
    const dy = (curr.clientY - prev.clientY) * DRAG_SENS;
    x += dx;
    y += dy;
    scheduleApply();
    return;
  }

  if (pointers.size === 2){
    // pinch zoom (damped + deadzone on iOS)
    const [p1, p2] = Array.from(pointers.values());
    const dist = getDist(p1, p2);

    if (!lastPinchDist){
      lastPinchDist = dist;
      return;
    }

    // ratio > 1 => zoom in, ratio < 1 => zoom out
    let ratio = dist / lastPinchDist;

    // deadzone: ignore micro-jitter
    if (Math.abs(ratio - 1) < PINCH_DEADZONE){
      lastPinchDist = dist;
      return;
    }

    // damp the pinch so it doesn’t explode on iOS:
    // convert ratio into a smaller step: 1 + (ratio-1)*PINCH_SENS
    ratio = 1 + ((ratio - 1) * PINCH_SENS);

    scale = clamp(scale * ratio, minScale, maxScale);
    scheduleApply();

    // update reference
    lastPinchDist = dist;
  }
});

function endPointer(e){
  pointers.delete(e.pointerId);
  if (pointers.size < 2) lastPinchDist = null;
  poster.releasePointerCapture?.(e.pointerId);
}
poster.addEventListener('pointerup', endPointer);
poster.addEventListener('pointercancel', endPointer);
    // ----- Mouse wheel zoom -----
    poster.addEventListener('wheel', (e) => {
      if(!poster.classList.contains('loaded')) return;
      e.preventDefault();
      const delta = -Math.sign(e.deltaY);
      const factor = (delta > 0) ? 1.08 : 0.92;
      scale = clamp(scale * factor, minScale, maxScale);
      apply();
    }, { passive: false });

    // ----- Capture helper -----
    async function captureCanvas(){
      return await html2canvas(poster, {
        scale: 2,
        backgroundColor: "#0b0c10",
        useCORS: true
      });
    }

    // Download PNG (desktop/Android). If iOS blocks it, open in new tab for long-press save.
    async function downloadPNG(){
      const canvas = await captureCanvas();
      const dataUrl = canvas.toDataURL("image/png");

      // Try download via anchor (works in most desktop browsers)
      try{
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = "poster.png";
        document.body.appendChild(a);
        a.click();
        a.remove();
      }catch{
        // Fallback
        window.open(dataUrl, "_blank");
      }

      // Extra iOS-friendly fallback: open image if download didn’t trigger
      // (Safari often ignores a.download)
      if (/iPhone|iPad|iPod/i.test(navigator.userAgent)){
        window.open(dataUrl, "_blank");
      }
    }

    // Copy PNG to clipboard (where supported). Fallback: open image in new tab.
    async function copyPNG(){
      const canvas = await captureCanvas();

      // ClipboardItem supported?
      if (!navigator.clipboard || !window.ClipboardItem){
        const dataUrl = canvas.toDataURL("image/png");
        window.open(dataUrl, "_blank");
        alert("Clipboard copy isn’t supported here. I opened the image — long-press to save/share.");
        return;
      }

      return new Promise((resolve) => {
        canvas.toBlob(async (blob) => {
          try{
            await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
            alert("Copied as PNG. You can paste it into messages/social apps that support image paste.");
            resolve();
          }catch(err){
            const dataUrl = canvas.toDataURL("image/png");
            window.open(dataUrl, "_blank");
            alert("Copy blocked by browser permissions. I opened the image — long-press to save/share.");
            resolve();
          }
        }, "image/png");
      });
    }

    downloadBtn.addEventListener('click', downloadPNG);
    copyBtn.addEventListener('click', copyPNG);

    // Resize/orientation changes: keep relative zoom level
    window.addEventListener('resize', () => {
      if (!poster.classList.contains('loaded')) return;
      const prevBase = baseScale || 1;
      const rel = scale / prevBase;

      baseScale = computeContainScale();
      minScale = baseScale * 0.35;
      maxScale = Math.max(3.0, baseScale * 6);

      scale = clamp(baseScale * rel, minScale, maxScale);
      apply();
    });

    pickAffirmation();
    apply();
  </script>
</body>
</html>
